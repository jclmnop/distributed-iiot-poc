// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: jclmnop.iiot_poc.interface.pangea_api

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message, MessageDispatch, MessageFormat,
        SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Envelope {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub err: Option<SearchErrors>,
    pub event: LogEvent,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hash: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership_proof: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_key: Option<String>,
    #[serde(default)]
    pub received_at: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
}

// Encode Envelope as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_envelope<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Envelope,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(7)?;
    if let Some(val) = val.err.as_ref() {
        e.str("err")?;
        encode_search_errors(e, val)?;
    } else {
        e.null()?;
    }
    e.str("event")?;
    encode_log_event(e, &val.event)?;
    if let Some(val) = val.hash.as_ref() {
        e.str("hash")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.membership_proof.as_ref() {
        e.str("membership_proof")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.public_key.as_ref() {
        e.str("public_key")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("received_at")?;
    e.str(&val.received_at)?;
    if let Some(val) = val.signature.as_ref() {
        e.str("signature")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode Envelope from cbor input stream
#[doc(hidden)]
pub fn decode_envelope(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Envelope, RpcError> {
    let __result = {
        let mut err: Option<Option<SearchErrors>> = Some(None);
        let mut event: Option<LogEvent> = None;
        let mut hash: Option<Option<String>> = Some(None);
        let mut membership_proof: Option<Option<String>> = Some(None);
        let mut public_key: Option<Option<String>> = Some(None);
        let mut received_at: Option<String> = None;
        let mut signature: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Envelope, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        err = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_errors(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchErrors': {}", e))? ))
                        }
                    }
                    1 => {
                        event = Some(decode_log_event(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                                e
                            )
                        })?)
                    }
                    2 => {
                        hash = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        public_key = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    5 => received_at = Some(d.str()?.to_string()),
                    6 => {
                        signature = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "err" => {
                        err = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_errors(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchErrors': {}", e))? ))
                        }
                    }
                    "event" => {
                        event = Some(decode_log_event(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                                e
                            )
                        })?)
                    }
                    "hash" => {
                        hash = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "membership_proof" => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "public_key" => {
                        public_key = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "received_at" => received_at = Some(d.str()?.to_string()),
                    "signature" => {
                        signature = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        Envelope {
            err: err.unwrap(),

            event: if let Some(__x) = event {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Envelope.event (#1)".to_string(),
                ));
            },
            hash: hash.unwrap(),
            membership_proof: membership_proof.unwrap(),
            public_key: public_key.unwrap(),

            received_at: if let Some(__x) = received_at {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Envelope.received_at (#5)".to_string(),
                ));
            },
            signature: signature.unwrap(),
        }
    };
    Ok(__result)
}
pub type Envelopes = Vec<Envelope>;

// Encode Envelopes as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_envelopes<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Envelopes,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_envelope(e, item)?;
    }
    Ok(())
}

// Decode Envelopes from cbor input stream
#[doc(hidden)]
pub fn decode_envelopes(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Envelopes, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Envelope> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_envelope(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelope': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Envelope> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_envelope(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelope': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// A log event which conforms to the [Pangea API](https://pangea.cloud/docs/audit/using-secure-audit-log/log-events)
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct LogEvent {
    /// This is used to record the action that occurred. Typical values seen in this field are "Create/Read/Update/Delete,"
    /// but could also include actions specific to your application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// The actor field is used to record who performed a specific action. This could be used to record the user ID,
    /// username, first and last name, or a combination of fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<String>,
    /// This field is used to record a detailed account of what action occurred. This can be recorded as free-form text
    /// or as a JSON field. If JSON is provided the log viewer will render this field as JSON.
    #[serde(default)]
    pub message: String,
    /// Used in combination with "old," new is used to record the value(s) of a record after a change has been made by
    /// the recorded action. If JSON is provided, the log viewer will render this field as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub new: Option<String>,
    /// This is usually used in combination with "new-value." Old-value is used to record the value(s) of a record before
    /// any change made by the recorded action. If JSON is provided, the log viewer will render this field as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old: Option<String>,
    /// The source field is for recording from where an activity occurred. This could be used to record a client's IP address,
    /// country of origin, the application used, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Status is used to record whether or not the action was successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// This is used to record the specific record that was targeted by the recorded action. This could be an object ID,
    /// a username, or other identifying information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// An optional client-supplied tenant_id
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    /// A Pangea-generated timestamp will always be provided with every log entry.
    /// This field is an optional client-supplied timestamp.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
}

// Encode LogEvent as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_log_event<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LogEvent,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(10)?;
    if let Some(val) = val.action.as_ref() {
        e.str("action")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.actor.as_ref() {
        e.str("actor")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("message")?;
    e.str(&val.message)?;
    if let Some(val) = val.new.as_ref() {
        e.str("new")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.old.as_ref() {
        e.str("old")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.source.as_ref() {
        e.str("source")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.status.as_ref() {
        e.str("status")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.target.as_ref() {
        e.str("target")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.tenant_id.as_ref() {
        e.str("tenant_id")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.timestamp.as_ref() {
        e.str("timestamp")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode LogEvent from cbor input stream
#[doc(hidden)]
pub fn decode_log_event(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<LogEvent, RpcError> {
    let __result = {
        let mut action: Option<Option<String>> = Some(None);
        let mut actor: Option<Option<String>> = Some(None);
        let mut message: Option<String> = None;
        let mut new: Option<Option<String>> = Some(None);
        let mut old: Option<Option<String>> = Some(None);
        let mut source: Option<Option<String>> = Some(None);
        let mut status: Option<Option<String>> = Some(None);
        let mut target: Option<Option<String>> = Some(None);
        let mut tenant_id: Option<Option<String>> = Some(None);
        let mut timestamp: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct LogEvent, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => message = Some(d.str()?.to_string()),
                    3 => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    5 => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    6 => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    7 => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    8 => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    9 => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "action" => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "actor" => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "message" => message = Some(d.str()?.to_string()),
                    "new" => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "old" => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "source" => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "status" => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "target" => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "tenant_id" => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "timestamp" => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        LogEvent {
            action: action.unwrap(),
            actor: actor.unwrap(),

            message: if let Some(__x) = message {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field LogEvent.message (#2)".to_string(),
                ));
            },
            new: new.unwrap(),
            old: old.unwrap(),
            source: source.unwrap(),
            status: status.unwrap(),
            target: target.unwrap(),
            tenant_id: tenant_id.unwrap(),
            timestamp: timestamp.unwrap(),
        }
    };
    Ok(__result)
}
pub type LogEvents = Vec<LogEvent>;

// Encode LogEvents as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_log_events<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LogEvents,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_log_event(e, item)?;
    }
    Ok(())
}

// Decode LogEvents from cbor input stream
#[doc(hidden)]
pub fn decode_log_events(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<LogEvents, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<LogEvent> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_log_event(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<LogEvent> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_log_event(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchError {
    #[serde(default)]
    pub error: String,
    #[serde(default)]
    pub field: String,
    #[serde(default)]
    pub value: String,
}

// Encode SearchError as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_error<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchError,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("error")?;
    e.str(&val.error)?;
    e.str("field")?;
    e.str(&val.field)?;
    e.str("value")?;
    e.str(&val.value)?;
    Ok(())
}

// Decode SearchError from cbor input stream
#[doc(hidden)]
pub fn decode_search_error(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchError, RpcError> {
    let __result = {
        let mut error: Option<String> = None;
        let mut field: Option<String> = None;
        let mut value: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SearchError, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => error = Some(d.str()?.to_string()),
                    1 => field = Some(d.str()?.to_string()),
                    2 => value = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "error" => error = Some(d.str()?.to_string()),
                    "field" => field = Some(d.str()?.to_string()),
                    "value" => value = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        SearchError {
            error: if let Some(__x) = error {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.error (#0)".to_string(),
                ));
            },

            field: if let Some(__x) = field {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.field (#1)".to_string(),
                ));
            },

            value: if let Some(__x) = value {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.value (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type SearchErrors = Vec<SearchError>;

// Encode SearchErrors as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_errors<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchErrors,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_search_error(e, item)?;
    }
    Ok(())
}

// Decode SearchErrors from cbor input stream
#[doc(hidden)]
pub fn decode_search_errors(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchErrors, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<SearchError> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_search_error(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchError': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<SearchError> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_search_error(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchError': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// API response
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchResponse {
    #[serde(default)]
    pub request_id: String,
    #[serde(default)]
    pub request_time: String,
    #[serde(default)]
    pub response_time: String,
    pub result: SearchResult,
    #[serde(default)]
    pub status: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
}

// Encode SearchResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    e.str("request_id")?;
    e.str(&val.request_id)?;
    e.str("request_time")?;
    e.str(&val.request_time)?;
    e.str("response_time")?;
    e.str(&val.response_time)?;
    e.str("result")?;
    encode_search_result(e, &val.result)?;
    e.str("status")?;
    e.str(&val.status)?;
    if let Some(val) = val.summary.as_ref() {
        e.str("summary")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode SearchResponse from cbor input stream
#[doc(hidden)]
pub fn decode_search_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchResponse, RpcError> {
    let __result =
        {
            let mut request_id: Option<String> = None;
            let mut request_time: Option<String> = None;
            let mut response_time: Option<String> = None;
            let mut result: Option<SearchResult> = None;
            let mut status: Option<String> = None;
            let mut summary: Option<Option<String>> = Some(None);

            let is_array = match d.datatype()? {
                wasmbus_rpc::cbor::Type::Array => true,
                wasmbus_rpc::cbor::Type::Map => false,
                _ => {
                    return Err(RpcError::Deser(
                        "decoding struct SearchResponse, expected array or map".to_string(),
                    ))
                }
            };
            if is_array {
                let len = d.fixed_array()?;
                for __i in 0..(len as usize) {
                    match __i {
                        0 => request_id = Some(d.str()?.to_string()),
                        1 => request_time = Some(d.str()?.to_string()),
                        2 => response_time = Some(d.str()?.to_string()),
                        3 => result = Some(decode_search_result(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchResult': {}",
                                e
                            )
                        })?),
                        4 => status = Some(d.str()?.to_string()),
                        5 => {
                            summary = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(d.str()?.to_string()))
                            }
                        }

                        _ => d.skip()?,
                    }
                }
            } else {
                let len = d.fixed_map()?;
                for __i in 0..(len as usize) {
                    match d.str()? {
                        "request_id" => request_id = Some(d.str()?.to_string()),
                        "request_time" => request_time = Some(d.str()?.to_string()),
                        "response_time" => response_time = Some(d.str()?.to_string()),
                        "result" => result = Some(decode_search_result(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchResult': {}",
                                e
                            )
                        })?),
                        "status" => status = Some(d.str()?.to_string()),
                        "summary" => {
                            summary = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(d.str()?.to_string()))
                            }
                        }
                        _ => d.skip()?,
                    }
                }
            }
            SearchResponse {
                request_id: if let Some(__x) = request_id {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResponse.request_id (#0)".to_string(),
                    ));
                },

                request_time: if let Some(__x) = request_time {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResponse.request_time (#1)".to_string(),
                    ));
                },

                response_time: if let Some(__x) = response_time {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResponse.response_time (#2)".to_string(),
                    ));
                },

                result: if let Some(__x) = result {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResponse.result (#3)".to_string(),
                    ));
                },

                status: if let Some(__x) = status {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResponse.status (#4)".to_string(),
                    ));
                },
                summary: summary.unwrap(),
            }
        };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchResult {
    #[serde(default)]
    pub count: u64,
    pub events: Envelopes,
}

// Encode SearchResult as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_result<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchResult,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("count")?;
    e.u64(val.count)?;
    e.str("events")?;
    encode_envelopes(e, &val.events)?;
    Ok(())
}

// Decode SearchResult from cbor input stream
#[doc(hidden)]
pub fn decode_search_result(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchResult, RpcError> {
    let __result =
        {
            let mut count: Option<u64> = None;
            let mut events: Option<Envelopes> = None;

            let is_array = match d.datatype()? {
                wasmbus_rpc::cbor::Type::Array => true,
                wasmbus_rpc::cbor::Type::Map => false,
                _ => {
                    return Err(RpcError::Deser(
                        "decoding struct SearchResult, expected array or map".to_string(),
                    ))
                }
            };
            if is_array {
                let len = d.fixed_array()?;
                for __i in 0..(len as usize) {
                    match __i {
                        0 => count = Some(d.u64()?),
                        1 => events = Some(decode_envelopes(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelopes': {}",
                                e
                            )
                        })?),
                        _ => d.skip()?,
                    }
                }
            } else {
                let len = d.fixed_map()?;
                for __i in 0..(len as usize) {
                    match d.str()? {
                        "count" => count = Some(d.u64()?),
                        "events" => events = Some(decode_envelopes(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelopes': {}",
                                e
                            )
                        })?),
                        _ => d.skip()?,
                    }
                }
            }
            SearchResult {
                count: if let Some(__x) = count {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResult.count (#0)".to_string(),
                    ));
                },

                events: if let Some(__x) = events {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResult.events (#1)".to_string(),
                    ));
                },
            }
        };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct WriteResult {
    /// Only needs to be checked if success is false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default)]
    pub success: bool,
}

// Encode WriteResult as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_write_result<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &WriteResult,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    if let Some(val) = val.reason.as_ref() {
        e.str("reason")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("success")?;
    e.bool(val.success)?;
    Ok(())
}

// Decode WriteResult from cbor input stream
#[doc(hidden)]
pub fn decode_write_result(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<WriteResult, RpcError> {
    let __result = {
        let mut reason: Option<Option<String>> = Some(None);
        let mut success: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct WriteResult, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        reason = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "reason" => {
                        reason = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "success" => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        WriteResult {
            reason: reason.unwrap(),

            success: if let Some(__x) = success {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field WriteResult.success (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// wasmbus.actorReceive
#[async_trait]
pub trait PangeaApi {
    async fn write_audit_log(&self, ctx: &Context, arg: &LogEvents) -> RpcResult<WriteResult>;
    async fn search_audit_log<TS: ToString + ?Sized + std::marker::Sync>(
        &self,
        ctx: &Context,
        arg: &TS,
    ) -> RpcResult<SearchResponse>;
}

/// PangeaApiReceiver receives messages defined in the PangeaApi service trait
#[doc(hidden)]
#[async_trait]
pub trait PangeaApiReceiver: MessageDispatch + PangeaApi {
    async fn dispatch(&self, ctx: &Context, message: Message<'_>) -> Result<Vec<u8>, RpcError> {
        match message.method {
            "WriteAuditLog" => {
                let value: LogEvents = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'LogEvents': {}", e)))?;

                let resp = PangeaApi::write_audit_log(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "SearchAuditLog" => {
                let value: String = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'String': {}", e)))?;

                let resp = PangeaApi::search_audit_log(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            _ => Err(RpcError::MethodNotHandled(format!(
                "PangeaApi::{}",
                message.method
            ))),
        }
    }
}

/// PangeaApiSender sends messages to a PangeaApi service
/// client for sending PangeaApi messages
#[derive(Clone, Debug)]
pub struct PangeaApiSender<T: Transport> {
    transport: T,
}

impl<T: Transport> PangeaApiSender<T> {
    /// Constructs a PangeaApiSender with the specified transport
    pub fn via(transport: T) -> Self {
        Self { transport }
    }

    pub fn set_timeout(&self, interval: std::time::Duration) {
        self.transport.set_timeout(interval);
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'send> PangeaApiSender<wasmbus_rpc::provider::ProviderTransport<'send>> {
    /// Constructs a Sender using an actor's LinkDefinition,
    /// Uses the provider's HostBridge for rpc
    pub fn for_actor(ld: &'send wasmbus_rpc::core::LinkDefinition) -> Self {
        Self {
            transport: wasmbus_rpc::provider::ProviderTransport::new(ld, None),
        }
    }
}
#[cfg(target_arch = "wasm32")]
impl PangeaApiSender<wasmbus_rpc::actor::prelude::WasmHost> {
    /// Constructs a client for actor-to-actor messaging
    /// using the recipient actor's public key
    pub fn to_actor(actor_id: &str) -> Self {
        let transport =
            wasmbus_rpc::actor::prelude::WasmHost::to_actor(actor_id.to_string()).unwrap();
        Self { transport }
    }
}
#[async_trait]
impl<T: Transport + std::marker::Sync + std::marker::Send> PangeaApi for PangeaApiSender<T> {
    #[allow(unused)]
    async fn write_audit_log(&self, ctx: &Context, arg: &LogEvents) -> RpcResult<WriteResult> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "PangeaApi.WriteAuditLog",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: WriteResult = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': WriteResult", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn search_audit_log<TS: ToString + ?Sized + std::marker::Sync>(
        &self,
        ctx: &Context,
        arg: &TS,
    ) -> RpcResult<SearchResponse> {
        let buf = wasmbus_rpc::common::serialize(&arg.to_string())?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "PangeaApi.SearchAuditLog",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: SearchResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': SearchResponse", e)))?;
        Ok(value)
    }
}
