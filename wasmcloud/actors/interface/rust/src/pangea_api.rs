// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: jclmnop.iiot_poc.interface.pangea_api

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message, MessageDispatch, MessageFormat,
        SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Envelope {
    pub envelope: EnvelopeInner,
    #[serde(default)]
    pub hash: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub leaf_index: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership_proof: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub published: Option<bool>,
}

// Encode Envelope as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_envelope<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Envelope,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    e.str("envelope")?;
    encode_envelope_inner(e, &val.envelope)?;
    e.str("hash")?;
    e.str(&val.hash)?;
    if let Some(val) = val.leaf_index.as_ref() {
        e.str("leaf_index")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.membership_proof.as_ref() {
        e.str("membership_proof")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.published.as_ref() {
        e.str("published")?;
        e.bool(*val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode Envelope from cbor input stream
#[doc(hidden)]
pub fn decode_envelope(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Envelope, RpcError> {
    let __result = {
        let mut envelope: Option<EnvelopeInner> = None;
        let mut hash: Option<String> = None;
        let mut leaf_index: Option<Option<u64>> = Some(None);
        let mut membership_proof: Option<Option<String>> = Some(None);
        let mut published: Option<Option<bool>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Envelope, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => envelope = Some(decode_envelope_inner(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#EnvelopeInner': {}",
                            e
                        )
                    })?),
                    1 => hash = Some(d.str()?.to_string()),
                    2 => {
                        leaf_index = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    3 => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        published = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.bool()?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "envelope" => envelope = Some(decode_envelope_inner(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#EnvelopeInner': {}",
                            e
                        )
                    })?),
                    "hash" => hash = Some(d.str()?.to_string()),
                    "leaf_index" => {
                        leaf_index = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "membership_proof" => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "published" => {
                        published = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.bool()?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        Envelope {
            envelope: if let Some(__x) = envelope {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Envelope.envelope (#0)".to_string(),
                ));
            },

            hash: if let Some(__x) = hash {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Envelope.hash (#1)".to_string(),
                ));
            },
            leaf_index: leaf_index.unwrap(),
            membership_proof: membership_proof.unwrap(),
            published: published.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct EnvelopeInner {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub err: Option<SearchErrors>,
    pub event: LogEvent,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hash: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub membership_proof: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_key: Option<String>,
    #[serde(default)]
    pub received_at: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
}

// Encode EnvelopeInner as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_envelope_inner<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &EnvelopeInner,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(7)?;
    if let Some(val) = val.err.as_ref() {
        e.str("err")?;
        encode_search_errors(e, val)?;
    } else {
        e.null()?;
    }
    e.str("event")?;
    encode_log_event(e, &val.event)?;
    if let Some(val) = val.hash.as_ref() {
        e.str("hash")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.membership_proof.as_ref() {
        e.str("membership_proof")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.public_key.as_ref() {
        e.str("public_key")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("received_at")?;
    e.str(&val.received_at)?;
    if let Some(val) = val.signature.as_ref() {
        e.str("signature")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode EnvelopeInner from cbor input stream
#[doc(hidden)]
pub fn decode_envelope_inner(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<EnvelopeInner, RpcError> {
    let __result = {
        let mut err: Option<Option<SearchErrors>> = Some(None);
        let mut event: Option<LogEvent> = None;
        let mut hash: Option<Option<String>> = Some(None);
        let mut membership_proof: Option<Option<String>> = Some(None);
        let mut public_key: Option<Option<String>> = Some(None);
        let mut received_at: Option<String> = None;
        let mut signature: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct EnvelopeInner, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        err = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_errors(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchErrors': {}", e))? ))
                        }
                    }
                    1 => {
                        event = Some(decode_log_event(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                                e
                            )
                        })?)
                    }
                    2 => {
                        hash = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        public_key = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    5 => received_at = Some(d.str()?.to_string()),
                    6 => {
                        signature = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "err" => {
                        err = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_errors(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchErrors': {}", e))? ))
                        }
                    }
                    "event" => {
                        event = Some(decode_log_event(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                                e
                            )
                        })?)
                    }
                    "hash" => {
                        hash = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "membership_proof" => {
                        membership_proof = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "public_key" => {
                        public_key = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "received_at" => received_at = Some(d.str()?.to_string()),
                    "signature" => {
                        signature = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        EnvelopeInner {
            err: err.unwrap(),

            event: if let Some(__x) = event {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field EnvelopeInner.event (#1)".to_string(),
                ));
            },
            hash: hash.unwrap(),
            membership_proof: membership_proof.unwrap(),
            public_key: public_key.unwrap(),

            received_at: if let Some(__x) = received_at {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field EnvelopeInner.received_at (#5)".to_string(),
                ));
            },
            signature: signature.unwrap(),
        }
    };
    Ok(__result)
}
pub type Envelopes = Vec<Envelope>;

// Encode Envelopes as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_envelopes<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Envelopes,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_envelope(e, item)?;
    }
    Ok(())
}

// Decode Envelopes from cbor input stream
#[doc(hidden)]
pub fn decode_envelopes(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Envelopes, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Envelope> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_envelope(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelope': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Envelope> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_envelope(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelope': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// A log event which conforms to the [Pangea API](https://pangea.cloud/docs/api/audit/?focus=audit#log-an-entry)
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct LogEvent {
    /// This is used to record the action that occurred. Typical values seen in this field are "Create/Read/Update/Delete,"
    /// but could also include actions specific to your application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// The actor field is used to record who performed a specific action. This could be used to record the user ID,
    /// username, first and last name, or a combination of fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<String>,
    /// This field is used to record a detailed account of what action occurred. This can be recorded as free-form text
    /// or as a JSON field. If JSON is provided the log viewer will render this field as JSON.
    #[serde(default)]
    pub message: String,
    /// Used in combination with "old," new is used to record the value(s) of a record after a change has been made by
    /// the recorded action. If JSON is provided, the log viewer will render this field as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub new: Option<String>,
    /// This is usually used in combination with "new-value." Old-value is used to record the value(s) of a record before
    /// any change made by the recorded action. If JSON is provided, the log viewer will render this field as JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old: Option<String>,
    /// The source field is for recording from where an activity occurred. This could be used to record a client's IP address,
    /// country of origin, the application used, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Status is used to record whether or not the action was successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// This is used to record the specific record that was targeted by the recorded action. This could be an object ID,
    /// a username, or other identifying information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// An optional client-supplied tenant_id
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    /// A Pangea-generated timestamp will always be provided with every log entry.
    /// This field is an optional client-supplied timestamp.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
}

// Encode LogEvent as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_log_event<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LogEvent,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(10)?;
    if let Some(val) = val.action.as_ref() {
        e.str("action")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.actor.as_ref() {
        e.str("actor")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("message")?;
    e.str(&val.message)?;
    if let Some(val) = val.new.as_ref() {
        e.str("new")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.old.as_ref() {
        e.str("old")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.source.as_ref() {
        e.str("source")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.status.as_ref() {
        e.str("status")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.target.as_ref() {
        e.str("target")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.tenant_id.as_ref() {
        e.str("tenant_id")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.timestamp.as_ref() {
        e.str("timestamp")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode LogEvent from cbor input stream
#[doc(hidden)]
pub fn decode_log_event(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<LogEvent, RpcError> {
    let __result = {
        let mut action: Option<Option<String>> = Some(None);
        let mut actor: Option<Option<String>> = Some(None);
        let mut message: Option<String> = None;
        let mut new: Option<Option<String>> = Some(None);
        let mut old: Option<Option<String>> = Some(None);
        let mut source: Option<Option<String>> = Some(None);
        let mut status: Option<Option<String>> = Some(None);
        let mut target: Option<Option<String>> = Some(None);
        let mut tenant_id: Option<Option<String>> = Some(None);
        let mut timestamp: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct LogEvent, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => message = Some(d.str()?.to_string()),
                    3 => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    5 => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    6 => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    7 => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    8 => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    9 => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "action" => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "actor" => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "message" => message = Some(d.str()?.to_string()),
                    "new" => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "old" => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "source" => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "status" => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "target" => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "tenant_id" => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "timestamp" => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        LogEvent {
            action: action.unwrap(),
            actor: actor.unwrap(),

            message: if let Some(__x) = message {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field LogEvent.message (#2)".to_string(),
                ));
            },
            new: new.unwrap(),
            old: old.unwrap(),
            source: source.unwrap(),
            status: status.unwrap(),
            target: target.unwrap(),
            tenant_id: tenant_id.unwrap(),
            timestamp: timestamp.unwrap(),
        }
    };
    Ok(__result)
}
pub type LogEvents = Vec<LogEvent>;

// Encode LogEvents as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_log_events<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &LogEvents,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_log_event(e, item)?;
    }
    Ok(())
}

// Decode LogEvents from cbor input stream
#[doc(hidden)]
pub fn decode_log_events(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<LogEvents, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<LogEvent> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_log_event(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<LogEvent> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_log_event(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#LogEvent': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Root {
    pub consistency_proof: Strings,
    #[serde(default)]
    pub published_at: String,
    #[serde(default)]
    pub root_hash: String,
    #[serde(default)]
    pub size: u64,
    #[serde(default)]
    pub tree_name: String,
    #[serde(default)]
    pub url: String,
}

// Encode Root as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_root<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Root,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    e.str("consistency_proof")?;
    encode_strings(e, &val.consistency_proof)?;
    e.str("published_at")?;
    e.str(&val.published_at)?;
    e.str("root_hash")?;
    e.str(&val.root_hash)?;
    e.str("size")?;
    e.u64(val.size)?;
    e.str("tree_name")?;
    e.str(&val.tree_name)?;
    e.str("url")?;
    e.str(&val.url)?;
    Ok(())
}

// Decode Root from cbor input stream
#[doc(hidden)]
pub fn decode_root(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Root, RpcError> {
    let __result = {
        let mut consistency_proof: Option<Strings> = None;
        let mut published_at: Option<String> = None;
        let mut root_hash: Option<String> = None;
        let mut size: Option<u64> = None;
        let mut tree_name: Option<String> = None;
        let mut url: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Root, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        consistency_proof = Some(decode_strings(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                e
                            )
                        })?)
                    }
                    1 => published_at = Some(d.str()?.to_string()),
                    2 => root_hash = Some(d.str()?.to_string()),
                    3 => size = Some(d.u64()?),
                    4 => tree_name = Some(d.str()?.to_string()),
                    5 => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "consistency_proof" => {
                        consistency_proof = Some(decode_strings(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                e
                            )
                        })?)
                    }
                    "published_at" => published_at = Some(d.str()?.to_string()),
                    "root_hash" => root_hash = Some(d.str()?.to_string()),
                    "size" => size = Some(d.u64()?),
                    "tree_name" => tree_name = Some(d.str()?.to_string()),
                    "url" => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        Root {
            consistency_proof: if let Some(__x) = consistency_proof {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Root.consistency_proof (#0)".to_string(),
                ));
            },

            published_at: if let Some(__x) = published_at {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Root.published_at (#1)".to_string(),
                ));
            },

            root_hash: if let Some(__x) = root_hash {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Root.root_hash (#2)".to_string(),
                ));
            },

            size: if let Some(__x) = size {
                __x
            } else {
                return Err(RpcError::Deser("missing field Root.size (#3)".to_string()));
            },

            tree_name: if let Some(__x) = tree_name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Root.tree_name (#4)".to_string(),
                ));
            },

            url: if let Some(__x) = url {
                __x
            } else {
                return Err(RpcError::Deser("missing field Root.url (#5)".to_string()));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchError {
    #[serde(default)]
    pub error: String,
    #[serde(default)]
    pub field: String,
    #[serde(default)]
    pub value: String,
}

// Encode SearchError as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_error<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchError,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("error")?;
    e.str(&val.error)?;
    e.str("field")?;
    e.str(&val.field)?;
    e.str("value")?;
    e.str(&val.value)?;
    Ok(())
}

// Decode SearchError from cbor input stream
#[doc(hidden)]
pub fn decode_search_error(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchError, RpcError> {
    let __result = {
        let mut error: Option<String> = None;
        let mut field: Option<String> = None;
        let mut value: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SearchError, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => error = Some(d.str()?.to_string()),
                    1 => field = Some(d.str()?.to_string()),
                    2 => value = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "error" => error = Some(d.str()?.to_string()),
                    "field" => field = Some(d.str()?.to_string()),
                    "value" => value = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        SearchError {
            error: if let Some(__x) = error {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.error (#0)".to_string(),
                ));
            },

            field: if let Some(__x) = field {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.field (#1)".to_string(),
                ));
            },

            value: if let Some(__x) = value {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchError.value (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type SearchErrors = Vec<SearchError>;

// Encode SearchErrors as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_errors<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchErrors,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_search_error(e, item)?;
    }
    Ok(())
}

// Decode SearchErrors from cbor input stream
#[doc(hidden)]
pub fn decode_search_errors(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchErrors, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<SearchError> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_search_error(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchError': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<SearchError> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_search_error(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchError': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// Parameters for searching the audit log, all fields are optional
/// Conforms to the [Pangea API](https://pangea.cloud/docs/api/audit/?focus=audit#search-the-log)
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchParams {
    /// A period of time or an absolute timestamp
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,
    /// Number of audit records to include from the first page of the results
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<u64>,
    /// Maximum number of results to return.
    /// min: 1
    /// max: 10,000
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_results: Option<u64>,
    /// Specify the sort order of the response.
    /// Options: `asc`, `desc`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<String>,
    /// Name of the colum to sort the results by.
    /// Options: `actor`, `action`, `message`, `new`, `old`, `source`,
    /// `status`, `target`, `timestamp`, `tenant_id`, `received_at`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order_by: Option<String>,
    /// Natural search string; a space-seprated list of case-sensitive values. Enclose strings in double-quotes " to
    /// include spaces. Optionally prefix with a field ID and a colon : to limit to a specific field.
    /// e.g. `"actor:John Smith" action:Create` will search for the string "John Smith" in the actor field and the
    /// string "Create" in the action field, returning results such as `actor:John Smith Jr The Third`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<String>,
    /// Optional parameters to restrict the scope of the search based on specific values.
    /// e.g. `"actor": ["John Smith", "Jane Doe"]` will only return results where the actor field is either "John Smith"
    /// or "Jane Doe". "John Smith Jr The Third" will not be returned.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub search_restriction: Option<SearchRestrictionParams>,
    /// A period of time or an absolute timestamp
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,
    /// If true, include the root hash of the tree and the membership proof for each record in the response.
    /// default: `false` (pangea API's default is true but we override this)
    #[serde(default)]
    pub verbose: bool,
}

// Encode SearchParams as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_params<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchParams,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(9)?;
    if let Some(val) = val.end.as_ref() {
        e.str("end")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.limit.as_ref() {
        e.str("limit")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.max_results.as_ref() {
        e.str("max_results")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.order.as_ref() {
        e.str("order")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.order_by.as_ref() {
        e.str("order_by")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.query.as_ref() {
        e.str("query")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.search_restriction.as_ref() {
        e.str("search_restriction")?;
        encode_search_restriction_params(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.start.as_ref() {
        e.str("start")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("verbose")?;
    e.bool(val.verbose)?;
    Ok(())
}

// Decode SearchParams from cbor input stream
#[doc(hidden)]
pub fn decode_search_params(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchParams, RpcError> {
    let __result = {
        let mut end: Option<Option<String>> = Some(None);
        let mut limit: Option<Option<u64>> = Some(None);
        let mut max_results: Option<Option<u64>> = Some(None);
        let mut order: Option<Option<String>> = Some(None);
        let mut order_by: Option<Option<String>> = Some(None);
        let mut query: Option<Option<String>> = Some(None);
        let mut search_restriction: Option<Option<SearchRestrictionParams>> = Some(None);
        let mut start: Option<Option<String>> = Some(None);
        let mut verbose: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SearchParams, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        end = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        limit = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    2 => {
                        max_results = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    3 => {
                        order = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        order_by = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    5 => {
                        query = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    6 => {
                        search_restriction = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_restriction_params(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchRestrictionParams': {}", e))? ))
                        }
                    }
                    7 => {
                        start = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    8 => verbose = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "end" => {
                        end = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "limit" => {
                        limit = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "max_results" => {
                        max_results = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "order" => {
                        order = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "order_by" => {
                        order_by = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "query" => {
                        query = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "search_restriction" => {
                        search_restriction = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_restriction_params(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchRestrictionParams': {}", e))? ))
                        }
                    }
                    "start" => {
                        start = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "verbose" => verbose = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        SearchParams {
            end: end.unwrap(),
            limit: limit.unwrap(),
            max_results: max_results.unwrap(),
            order: order.unwrap(),
            order_by: order_by.unwrap(),
            query: query.unwrap(),
            search_restriction: search_restriction.unwrap(),
            start: start.unwrap(),

            verbose: if let Some(__x) = verbose {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchParams.verbose (#8)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// API response
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchResponse {
    #[serde(default)]
    pub request_id: String,
    #[serde(default)]
    pub request_time: String,
    #[serde(default)]
    pub response_time: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub result: Option<SearchResult>,
    #[serde(default)]
    pub status: String,
    #[serde(default)]
    pub summary: String,
}

// Encode SearchResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    e.str("request_id")?;
    e.str(&val.request_id)?;
    e.str("request_time")?;
    e.str(&val.request_time)?;
    e.str("response_time")?;
    e.str(&val.response_time)?;
    if let Some(val) = val.result.as_ref() {
        e.str("result")?;
        encode_search_result(e, val)?;
    } else {
        e.null()?;
    }
    e.str("status")?;
    e.str(&val.status)?;
    e.str("summary")?;
    e.str(&val.summary)?;
    Ok(())
}

// Decode SearchResponse from cbor input stream
#[doc(hidden)]
pub fn decode_search_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchResponse, RpcError> {
    let __result = {
        let mut request_id: Option<String> = None;
        let mut request_time: Option<String> = None;
        let mut response_time: Option<String> = None;
        let mut result: Option<Option<SearchResult>> = Some(None);
        let mut status: Option<String> = None;
        let mut summary: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SearchResponse, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => request_id = Some(d.str()?.to_string()),
                    1 => request_time = Some(d.str()?.to_string()),
                    2 => response_time = Some(d.str()?.to_string()),
                    3 => {
                        result = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_result(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchResult': {}", e))? ))
                        }
                    }
                    4 => status = Some(d.str()?.to_string()),
                    5 => summary = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "request_id" => request_id = Some(d.str()?.to_string()),
                    "request_time" => request_time = Some(d.str()?.to_string()),
                    "response_time" => response_time = Some(d.str()?.to_string()),
                    "result" => {
                        result = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_search_result(d).map_err(|e| format!("decoding 'jclmnop.iiot_poc.interface.pangea_api#SearchResult': {}", e))? ))
                        }
                    }
                    "status" => status = Some(d.str()?.to_string()),
                    "summary" => summary = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        SearchResponse {
            request_id: if let Some(__x) = request_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchResponse.request_id (#0)".to_string(),
                ));
            },

            request_time: if let Some(__x) = request_time {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchResponse.request_time (#1)".to_string(),
                ));
            },

            response_time: if let Some(__x) = response_time {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchResponse.response_time (#2)".to_string(),
                ));
            },
            result: result.unwrap(),

            status: if let Some(__x) = status {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchResponse.status (#4)".to_string(),
                ));
            },

            summary: if let Some(__x) = summary {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SearchResponse.summary (#5)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// Parameters for restricting search results, for example if you only wanted
/// to see events from a specific actor or source
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchRestrictionParams {
    /// A list of actions to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<Strings>,
    /// A list of actors to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actor: Option<Strings>,
    /// A list of messages to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<Strings>,
    /// A list of new values to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub new: Option<Strings>,
    /// A list of old values to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old: Option<Strings>,
    /// A list of received_at timestamps to restrict the search to. This is the
    /// timestamp provided by Pangea when logging the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received_at: Option<Strings>,
    /// A list of sources to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<Strings>,
    /// A list of statuses to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<Strings>,
    /// A list of targets to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<Strings>,
    /// A list of tenant_ids to restrict the search to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<Strings>,
    /// A list of timestamps to restrict the search to. This is the timestamp
    /// provided by the client when logging the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<Strings>,
}

// Encode SearchRestrictionParams as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_restriction_params<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchRestrictionParams,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(11)?;
    if let Some(val) = val.action.as_ref() {
        e.str("action")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.actor.as_ref() {
        e.str("actor")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.message.as_ref() {
        e.str("message")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.new.as_ref() {
        e.str("new")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.old.as_ref() {
        e.str("old")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.received_at.as_ref() {
        e.str("received_at")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.source.as_ref() {
        e.str("source")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.status.as_ref() {
        e.str("status")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.target.as_ref() {
        e.str("target")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.tenant_id.as_ref() {
        e.str("tenant_id")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.timestamp.as_ref() {
        e.str("timestamp")?;
        encode_strings(e, val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode SearchRestrictionParams from cbor input stream
#[doc(hidden)]
pub fn decode_search_restriction_params(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchRestrictionParams, RpcError> {
    let __result = {
        let mut action: Option<Option<Strings>> = Some(None);
        let mut actor: Option<Option<Strings>> = Some(None);
        let mut message: Option<Option<Strings>> = Some(None);
        let mut new: Option<Option<Strings>> = Some(None);
        let mut old: Option<Option<Strings>> = Some(None);
        let mut received_at: Option<Option<Strings>> = Some(None);
        let mut source: Option<Option<Strings>> = Some(None);
        let mut status: Option<Option<Strings>> = Some(None);
        let mut target: Option<Option<Strings>> = Some(None);
        let mut tenant_id: Option<Option<Strings>> = Some(None);
        let mut timestamp: Option<Option<Strings>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SearchRestrictionParams, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    1 => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    2 => {
                        message = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    3 => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    4 => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    5 => {
                        received_at = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    6 => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    7 => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    8 => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    9 => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    10 => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "action" => {
                        action = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "actor" => {
                        actor = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "message" => {
                        message = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "new" => {
                        new = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "old" => {
                        old = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "received_at" => {
                        received_at = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "source" => {
                        source = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "status" => {
                        status = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "target" => {
                        target = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "tenant_id" => {
                        tenant_id = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "timestamp" => {
                        timestamp = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_strings(d).map_err(|e| {
                                format!(
                                    "decoding 'jclmnop.iiot_poc.interface.pangea_api#Strings': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        SearchRestrictionParams {
            action: action.unwrap(),
            actor: actor.unwrap(),
            message: message.unwrap(),
            new: new.unwrap(),
            old: old.unwrap(),
            received_at: received_at.unwrap(),
            source: source.unwrap(),
            status: status.unwrap(),
            target: target.unwrap(),
            tenant_id: tenant_id.unwrap(),
            timestamp: timestamp.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SearchResult {
    #[serde(default)]
    pub count: u64,
    pub events: Envelopes,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root: Option<Root>,
}

// Encode SearchResult as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_search_result<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SearchResult,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("count")?;
    e.u64(val.count)?;
    e.str("events")?;
    encode_envelopes(e, &val.events)?;
    if let Some(val) = val.root.as_ref() {
        e.str("root")?;
        encode_root(e, val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode SearchResult from cbor input stream
#[doc(hidden)]
pub fn decode_search_result(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SearchResult, RpcError> {
    let __result =
        {
            let mut count: Option<u64> = None;
            let mut events: Option<Envelopes> = None;
            let mut root: Option<Option<Root>> = Some(None);

            let is_array = match d.datatype()? {
                wasmbus_rpc::cbor::Type::Array => true,
                wasmbus_rpc::cbor::Type::Map => false,
                _ => {
                    return Err(RpcError::Deser(
                        "decoding struct SearchResult, expected array or map".to_string(),
                    ))
                }
            };
            if is_array {
                let len = d.fixed_array()?;
                for __i in 0..(len as usize) {
                    match __i {
                        0 => count = Some(d.u64()?),
                        1 => events = Some(decode_envelopes(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelopes': {}",
                                e
                            )
                        })?),
                        2 => {
                            root = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(decode_root(d).map_err(|e| {
                                    format!(
                                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#Root': {}",
                                        e
                                    )
                                })?))
                            }
                        }

                        _ => d.skip()?,
                    }
                }
            } else {
                let len = d.fixed_map()?;
                for __i in 0..(len as usize) {
                    match d.str()? {
                        "count" => count = Some(d.u64()?),
                        "events" => events = Some(decode_envelopes(d).map_err(|e| {
                            format!(
                                "decoding 'jclmnop.iiot_poc.interface.pangea_api#Envelopes': {}",
                                e
                            )
                        })?),
                        "root" => {
                            root = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(decode_root(d).map_err(|e| {
                                    format!(
                                        "decoding 'jclmnop.iiot_poc.interface.pangea_api#Root': {}",
                                        e
                                    )
                                })?))
                            }
                        }
                        _ => d.skip()?,
                    }
                }
            }
            SearchResult {
                count: if let Some(__x) = count {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResult.count (#0)".to_string(),
                    ));
                },

                events: if let Some(__x) = events {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field SearchResult.events (#1)".to_string(),
                    ));
                },
                root: root.unwrap(),
            }
        };
    Ok(__result)
}
pub type Strings = Vec<String>;

// Encode Strings as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_strings<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Strings,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.str(item)?;
    }
    Ok(())
}

// Decode Strings from cbor input stream
#[doc(hidden)]
pub fn decode_strings(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Strings, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<String> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.str()?.to_string())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<String> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.str()?.to_string()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct WriteResult {
    /// Only needs to be checked if success is false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default)]
    pub success: bool,
}

// Encode WriteResult as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_write_result<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &WriteResult,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    if let Some(val) = val.reason.as_ref() {
        e.str("reason")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("success")?;
    e.bool(val.success)?;
    Ok(())
}

// Decode WriteResult from cbor input stream
#[doc(hidden)]
pub fn decode_write_result(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<WriteResult, RpcError> {
    let __result = {
        let mut reason: Option<Option<String>> = Some(None);
        let mut success: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct WriteResult, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        reason = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "reason" => {
                        reason = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "success" => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        WriteResult {
            reason: reason.unwrap(),

            success: if let Some(__x) = success {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field WriteResult.success (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// wasmbus.actorReceive
#[async_trait]
pub trait PangeaApi {
    async fn write_audit_log(&self, ctx: &Context, arg: &LogEvents) -> RpcResult<WriteResult>;
    async fn search_audit_log(
        &self,
        ctx: &Context,
        arg: &SearchParams,
    ) -> RpcResult<SearchResponse>;
}

/// PangeaApiReceiver receives messages defined in the PangeaApi service trait
#[doc(hidden)]
#[async_trait]
pub trait PangeaApiReceiver: MessageDispatch + PangeaApi {
    async fn dispatch(&self, ctx: &Context, message: Message<'_>) -> Result<Vec<u8>, RpcError> {
        match message.method {
            "WriteAuditLog" => {
                let value: LogEvents = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'LogEvents': {}", e)))?;

                let resp = PangeaApi::write_audit_log(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "SearchAuditLog" => {
                let value: SearchParams = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'SearchParams': {}", e)))?;

                let resp = PangeaApi::search_audit_log(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            _ => Err(RpcError::MethodNotHandled(format!(
                "PangeaApi::{}",
                message.method
            ))),
        }
    }
}

/// PangeaApiSender sends messages to a PangeaApi service
/// client for sending PangeaApi messages
#[derive(Clone, Debug)]
pub struct PangeaApiSender<T: Transport> {
    transport: T,
}

impl<T: Transport> PangeaApiSender<T> {
    /// Constructs a PangeaApiSender with the specified transport
    pub fn via(transport: T) -> Self {
        Self { transport }
    }

    pub fn set_timeout(&self, interval: std::time::Duration) {
        self.transport.set_timeout(interval);
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'send> PangeaApiSender<wasmbus_rpc::provider::ProviderTransport<'send>> {
    /// Constructs a Sender using an actor's LinkDefinition,
    /// Uses the provider's HostBridge for rpc
    pub fn for_actor(ld: &'send wasmbus_rpc::core::LinkDefinition) -> Self {
        Self {
            transport: wasmbus_rpc::provider::ProviderTransport::new(ld, None),
        }
    }
}
#[cfg(target_arch = "wasm32")]
impl PangeaApiSender<wasmbus_rpc::actor::prelude::WasmHost> {
    /// Constructs a client for actor-to-actor messaging
    /// using the recipient actor's public key
    pub fn to_actor(actor_id: &str) -> Self {
        let transport =
            wasmbus_rpc::actor::prelude::WasmHost::to_actor(actor_id.to_string()).unwrap();
        Self { transport }
    }
}
#[async_trait]
impl<T: Transport + std::marker::Sync + std::marker::Send> PangeaApi for PangeaApiSender<T> {
    #[allow(unused)]
    async fn write_audit_log(&self, ctx: &Context, arg: &LogEvents) -> RpcResult<WriteResult> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "PangeaApi.WriteAuditLog",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: WriteResult = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': WriteResult", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn search_audit_log(
        &self,
        ctx: &Context,
        arg: &SearchParams,
    ) -> RpcResult<SearchResponse> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "PangeaApi.SearchAuditLog",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: SearchResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': SearchResponse", e)))?;
        Ok(value)
    }
}
